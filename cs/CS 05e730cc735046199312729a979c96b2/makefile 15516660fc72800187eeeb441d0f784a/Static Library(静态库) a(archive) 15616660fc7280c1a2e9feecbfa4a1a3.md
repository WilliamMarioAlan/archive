# Static Library(静态库).a(archive)

ar rcs libmath_utils.a math_utils.o

`rcs`：选项表示 *replace*（替换文件）、*create*（创建归档文件）、*index*（生成索引）。

- 生成动态库：`libmath_utils.so`。

生成静态库：`libmath_utils.a`。

在 Windows 上，动态库的扩展名为 `.dll`（Dynamic Link Library），静态库的扩展名为 `.lib`，名称约定略有不同。

---

### **`.a`：静态库 (Static Library)**

- **全称**：Archive。
- **特点**：
    - 在**编译链接阶段**，静态库的内容会被嵌入到最终的可执行文件中。
    - 静态库编译后，生成的可执行文件不需要依赖外部的库文件即可运行。
    - 一旦静态库更新，需要重新编译链接可执行文件才能反映更新内容。
    - 编译后生成的可执行文件较大，因为库的内容完全复制到其中。
- **优点**：
    - 不需要在运行时额外加载库文件。
    - 分发可执行文件时，不需要附带库文件。
- **缺点**：
    - 编译后的可执行文件体积较大。
    - 更新静态库时，需要重新编译所有依赖该库的程序。
- **创建静态库**：
    1. 编译目标文件：
        
        ```bash
        gcc -c mylib.c -o mylib.o
        
        ```
        
    2. 生成静态库：
        
        ```bash
        ar rcs libmylib.a mylib.o
        
        ```
        
        - `ar` 是 GNU 提供的打包工具。
        - `rcs` 表示 `replace`, `create`, `index`。
    3. 使用静态库：
        
        ```bash
        gcc main.c -L. -lmylib -o myprogram
        
        ```
        
        - `L.`：指定库文件目录。
        - `lmylib`：链接静态库 `libmylib.a`。

---

### **`.a` 和 `.so` 的区别**

| 特性 | 静态库 (`.a`) | 动态库 (`.so`) |
| --- | --- | --- |
| **加载时机** | 编译和链接阶段 | 程序运行时 |
| **文件大小** | 编译后的可执行文件较大 | 编译后的可执行文件较小 |
| **内存占用** | 每个程序有自己的库副本 | 多个程序共享一份动态库 |
| **更新方式** | 更新库后需要重新编译程序 | 更新库后程序直接使用新版本 |
| **分发难度** | 分发程序无需额外提供库文件 | 分发程序时需要确保动态库存在 |
| **使用场景** | 稳定性优先，程序无需动态依赖 | 体积和可维护性优先 |

---

### **总结**

- **静态库** (`.a`)：将库文件直接嵌入到可执行文件中。适合需要分发独立程序的场景。
- **动态库** (`.so`)：在运行时加载库文件。适合需要共享库文件、节省存储空间和内存的场景。

在项目中，选择静态库还是动态库需要根据实际需求权衡：

- 如果程序分发时需要独立性（无需依赖运行环境），可以选择静态库。
- 如果需要减少程序体积或便于库的维护和更新，动态库是更好的选择。